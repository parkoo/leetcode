package main

// 思路: 指数的二进制算法
// 指数的每个二进制数位都有一个权值，权值如下图所示，最终结果就等于所有二进制位为1的权值之积,
// 例如 x^77次方对应的二进制 (1001101) 和每个二进制位的权值如下

// 1     0     0     1    1    0    1
// x^64  x^32  x^16  x^8  x^4  x^2  x^1

// 最终结果就是所有二进制位为1的权值之积：x^1 * x^4 * x^8 * x^64 = x^77

// 时间复杂度: O(logn)    空间复杂度: O(1)

func myPow_2(x float64, n int) float64 {
	res := 1.0

	if n < 0 {
		x = 1 / x
		n = -n
	}

	pow := n
	for pow > 0 {
		if pow&1 == 1 { // 判断pow的二进制最后一位是否为1  或者 pow%2 == 1 (二进制最后一位为1的数一定是奇数)
			res *= x
		}

		x = x * x // 计算下一轮的x

		pow /= 2 // pow的二进制左移一位
	}

	return res
}
