package main

// 思路: 动态规划

// 时间复杂度：O(n^2)  空间复杂度：O(n)

func numTrees_1(n int) int {

	// dp[i] = k 表示由i个不同的节点，可以构成的不同二叉树的个数
	// 若有n个节点，分别选择以节点1、2、...、n 作为根节点可以构成的不同二叉树的个数，再求其和便是这n个节点构成的不同二叉树的个数
	// 假设以节点j作为根节点（1<=j<=n），则说明左子树有j-1个节点，可以构成dp[j-1]个不同的二叉树，而右子树有i-j个节点，可以构成dp[i-j]个不同的二叉树
	// 故以节点j作为根节点，可以构成dp[j-1]*dp[i-j]个不同的二叉树

	// 举例：
	// 共有i个节点，分别以第j个节点(1<=j<=i)作为根节点，求得这i个节点可以构成多少种二叉树
	//假设 i = 5
	// 当根节点等于 1 时 ，其余数字都比1大，只能在右边 dp[i] += dp[4]
	// 当根节点等于 2 时，左边有一个1比2小，右边有三个比2大的数字 dp[i] += dp[1] * dp[3]
	// 当根节点等于 3 时，左边有两个数比3小，右边有两个数比3大的数字 dp[i] += dp[2] * dp[2]
	// ...
	// 知道根节点等于5，左边有4个数字比5小，只能放在5的左边,dp[i] += dp[4]

	dp := make([]int, n+1)
	dp[0] = 1
	dp[1] = 1

	// 当前有i个节点，分别以节点j（j<=i）作为根节点进行二分搜索树的构建
	for i := 2; i <= n; i++ {
		for j := 1; j <= i; j++ {
			leftCnt := dp[j-1]
			rightCnt := dp[i-j]
			dp[i] += leftCnt * rightCnt
		}
	}

	return dp[n]
}
